from time import time
import os
from src.fasta import write_fasta
from functools import reduce
from itertools import groupby


class Record:
    def __init__(self, name,  lens):
        self.name1 = int(name.split('_')[0])
        self.name2 = int(name.split('_')[1])
        self.record = [0] * lens
        self.lens = lens

    def merge(self, a, b):
        for t in range(a - 1, b - 1):
            self.record[t] += 1

    def print_record(self):
        text = [str(i) if i < 10 else '+' for i in self.record]
        print("".join(text))

    def output_record(self, out):
        out.write("no,count\n")
        for t in range(self.lens):
            out.write("{0},{1}\n".format(t, self.record[t]))


class ValidationManager:
    def __init__(self, _dm, _lm, _dbm):
        self.dm = _dm
        self.lm = _lm
        self.dbm = _dbm
        self.maxmatch_length = 4
        self.virus_min_count = 10

    def internal_accuracy_validation(self):
        pass

    def validate(self, query_fasta):
        '''
        :param query_fasta list containing fasta
        :return: result dictionary containing Record
        '''
        v_dir = self.dm.add_temp_folder("v_{}".format(int(time())))
        query = self.make_temp_fasta(query_fasta)
        reference = self.make_temp_fasta(self.dbm.make_reference())
        query_output = os.path.join(v_dir, "query.maxmatch")
        os.system("./mummer -maxmatch -L -l {0} {1} {2} > {3}".format(
            self.maxmatch_length,
            reference,
            query,
            query_output
        ))

        result = ValidationManager.parse_query_output(query_output)
        self.remove_temp_fasta(reference)
        self.remove_temp_fasta(query)
        self.dm.remove_temp_folder(v_dir)
        return result

    def make_temp_fasta(self, fasta):
        name = os.path.join(self.dm.validation_dir, "validation_{}".format(int(time())))
        out = open(name, 'w')
        for f in fasta:
            write_fasta(out, f)
        out.close()
        return name

    @staticmethod
    def remove_temp_fasta(name):
        if os.path.isfile(name):
            os.remove(name)

    @staticmethod
    def parse_query_output(qo):
        '''
        :param      qo: query output (*.maxmatch) using mummer with -L flag
        :return:    result:
        '''
        qo_file = open(qo)
        query_result = []

        current_query_name = ""
        current_query_length = 0
        current_result = None
        for line in qo_file:
            if line.startswith('>'):
                current_query_name = line.split()[1]
                current_query_length = int(line.split()[-1])
                current_result = Record(current_query_name, current_query_length)
                query_result.append(current_result)
                continue
            ValidationManager.query_result_line_handler(current_result, line)
        return query_result

    @staticmethod
    def query_result_line_handler(result, line):
        t = line.rsplit()
        rid, rstart, qstart, qlens = t[0], int(t[1]), int(t[2]), int(t[3])
        result.merge(qstart, qstart + qlens)


class Judge:
    def __init__(self, classifier, rule):
        self.cf = classifier
        self.rule = rule

    def judge(self, query_result):
        ret = dict()
        for pid, query in groupby(sorted(query_result, key=lambda x: x.name1), key=lambda x: x.name1):
            count_rule = reduce(
                lambda count, b:
                count + 1 if self.rule(b) else count,
                query_result,
                0
            )
            ret[pid] = count_rule
        return ret

    def result(self, query_result):
        return [(q, self.cf(q), self.rule(q)) for q in query_result]

    def summary(self, query_result):
        count_and = reduce(
            lambda count, b:
            count + 1 if self.cf(b) and self.rule(b) else count,
            query_result,
            0
        )
        count_cf = reduce(
            lambda count, b:
            count + 1 if self.cf(b) else count,
            query_result,
            0
        )
        count_rule = reduce(
            lambda count, b:
            count + 1 if self.rule(b) else count,
            query_result,
            0
        )
        count_ff = reduce(
            lambda count, b:
            count if self.cf(b) or self.rule(b) else count + 1,
            query_result,
            0
        )

        tt, tf, ft, ff = count_and, count_cf - count_and, count_rule - count_and, count_ff
        return tt, tf, ft, ff

    def acc(self, query_result):
        tt, tf, ft, ff = self.summary(query_result)
        return (tt + ff) / len(query_result)



